{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"bash-object Manipulate heterogenous data hierarchies in Bash Contents What are you doing here? Looking at documentation for this crazy library? :tongue_sticking_out: Unfortunately, you won't find any Getting Started guides, but you'll find some other things: The Motivation for building this library The Interfaces for generating and modifcying objects The syntax for making Queries into objects A short Reference containing some relevant environment variables","title":"bash-object"},{"location":"#bash-object","text":"Manipulate heterogenous data hierarchies in Bash","title":"bash-object"},{"location":"#contents","text":"What are you doing here? Looking at documentation for this crazy library? :tongue_sticking_out: Unfortunately, you won't find any Getting Started guides, but you'll find some other things: The Motivation for building this library The Interfaces for generating and modifcying objects The syntax for making Queries into objects A short Reference containing some relevant environment variables","title":"Contents"},{"location":"interface/","text":"Interface The bobject command generally allows you to 'set' and 'get' different types of variables from some object hierarchy (think JSON object) bobject get-* Get operations have two mutually exclusive modes, specified with either --ref or --value as flags. If you are not sure which to use, pass --value ref In ref mode, REPLY is a string that is set with the value of the global variable that contains the content you queried for. This functionality is not yet implemented value In value mode, the REPLY contains the actual value you want bobject-set-* Set operations have two mutually exclusive modes, specified with either --ref or --value as flags. If you are not sure which to use, pass --ref ref In ref mode, a third argument is passed, which is a string that is set to the name of a variable. When setting a field in the object hierarchy, the contents of that particular variable is copied into the hierarchy value In value mode, there is no third argument. After supplying the first two arguments, add -- , then supply whatever value you want to be used when setting a field in the object hierarchy. This works with variable types string , array , and object","title":"Interface"},{"location":"interface/#interface","text":"The bobject command generally allows you to 'set' and 'get' different types of variables from some object hierarchy (think JSON object)","title":"Interface"},{"location":"interface/#bobject-get-","text":"Get operations have two mutually exclusive modes, specified with either --ref or --value as flags. If you are not sure which to use, pass --value","title":"bobject get-*"},{"location":"interface/#ref","text":"In ref mode, REPLY is a string that is set with the value of the global variable that contains the content you queried for. This functionality is not yet implemented","title":"ref"},{"location":"interface/#value","text":"In value mode, the REPLY contains the actual value you want","title":"value"},{"location":"interface/#bobject-set-","text":"Set operations have two mutually exclusive modes, specified with either --ref or --value as flags. If you are not sure which to use, pass --ref","title":"bobject-set-*"},{"location":"interface/#ref_1","text":"In ref mode, a third argument is passed, which is a string that is set to the name of a variable. When setting a field in the object hierarchy, the contents of that particular variable is copied into the hierarchy","title":"ref"},{"location":"interface/#value_1","text":"In value mode, there is no third argument. After supplying the first two arguments, add -- , then supply whatever value you want to be used when setting a field in the object hierarchy. This works with variable types string , array , and object","title":"value"},{"location":"motivation/","text":"Motivation Unmarshaling strings representing highly structured data in Bash in a reliable and easy to use way has historically been impossible Bash only allows for simple/flat mapping via an associative array { \"atom\": \"Hydrogen\" } assert [ \"${OBJECT[atom]}\" = 'Hydrogen' ] But, when it comes to even the slightest of more complicated structures, Bash cannot cope: associative arrays do not nest inside one another { \"stars\": { \"cool\": \"Wolf 359\" } } Note only that, but indexed arrays cannot nest inside associative arrays { \"nearby\": [ \"Alpha Centauri A\", \"Alpha Centauri B\", \"Proxima Centauri\", \"Barnard's Star\", \"Luhman 16\" ] } Solution bash-object solves this problem, in the most general case. The repository contains functions for storing and retreiving strings, indexed arrays, and associative arrays in a heterogenous hierarchy Let's take a look at the most basic case { \"xray\": { \"yankee\": \"zulu\" } } In Bash, it will be stored in memory eventually using declarations similar to the following declare -A __bash_object_unique_global_variable_xray=([yankee]='zulu') declare -A OBJECT=([xray]=$'\\x1C\\x1Dtype=object;&__bash_object_unique_global_variable_xray') You can retrieve the data with bobject get-object --value 'OBJECT' 'xray' assert [ \"${REPLY[yankee]}\" = zulu ] The implementation hinges on Bash's declare -n . When using get-object , this is what would happen behind the scenes at the lowest level local current_object_name='__bash_object_unique_global_variable_xray' local -n current_object=\"$current_object_name\" declare -gA REPLY=() local key= for key in \"${!current_object[@]}\"; do REPLY[\"$key\"]=\"${current_object[$key]}\" done Another implementation detail is how a new variable is created in the global scope. This can occur when you are setting an array (indexed array) or object (associative array) at some place in the object hierarchy. In the previous example, __bash_object_unique_global_variable_xray is the new variable created in the global scope; in practice, the name looks a lot different, as seen in the example below local global_object_name= printf -v global_object_name '%q' \"__bash_object_${root_object_name}_${root_object_query}_${RANDOM}_${RANDOM}\" if ! declare -gA \"$global_object_name\"; then bash_object.util.die 'ERROR_INTERNAL' \"Could not declare variable '$global_object_name'\" return fi local -n global_object=\"$global_object_name\" global_object=() The %q probably isn't needed (it was originally there because the implementation previously used eval ), but it's still there as of this writing","title":"Motivation"},{"location":"motivation/#motivation","text":"Unmarshaling strings representing highly structured data in Bash in a reliable and easy to use way has historically been impossible Bash only allows for simple/flat mapping via an associative array { \"atom\": \"Hydrogen\" } assert [ \"${OBJECT[atom]}\" = 'Hydrogen' ] But, when it comes to even the slightest of more complicated structures, Bash cannot cope: associative arrays do not nest inside one another { \"stars\": { \"cool\": \"Wolf 359\" } } Note only that, but indexed arrays cannot nest inside associative arrays { \"nearby\": [ \"Alpha Centauri A\", \"Alpha Centauri B\", \"Proxima Centauri\", \"Barnard's Star\", \"Luhman 16\" ] }","title":"Motivation"},{"location":"motivation/#solution","text":"bash-object solves this problem, in the most general case. The repository contains functions for storing and retreiving strings, indexed arrays, and associative arrays in a heterogenous hierarchy Let's take a look at the most basic case { \"xray\": { \"yankee\": \"zulu\" } } In Bash, it will be stored in memory eventually using declarations similar to the following declare -A __bash_object_unique_global_variable_xray=([yankee]='zulu') declare -A OBJECT=([xray]=$'\\x1C\\x1Dtype=object;&__bash_object_unique_global_variable_xray') You can retrieve the data with bobject get-object --value 'OBJECT' 'xray' assert [ \"${REPLY[yankee]}\" = zulu ] The implementation hinges on Bash's declare -n . When using get-object , this is what would happen behind the scenes at the lowest level local current_object_name='__bash_object_unique_global_variable_xray' local -n current_object=\"$current_object_name\" declare -gA REPLY=() local key= for key in \"${!current_object[@]}\"; do REPLY[\"$key\"]=\"${current_object[$key]}\" done Another implementation detail is how a new variable is created in the global scope. This can occur when you are setting an array (indexed array) or object (associative array) at some place in the object hierarchy. In the previous example, __bash_object_unique_global_variable_xray is the new variable created in the global scope; in practice, the name looks a lot different, as seen in the example below local global_object_name= printf -v global_object_name '%q' \"__bash_object_${root_object_name}_${root_object_query}_${RANDOM}_${RANDOM}\" if ! declare -gA \"$global_object_name\"; then bash_object.util.die 'ERROR_INTERNAL' \"Could not declare variable '$global_object_name'\" return fi local -n global_object=\"$global_object_name\" global_object=() The %q probably isn't needed (it was originally there because the implementation previously used eval ), but it's still there as of this writing","title":"Solution"},{"location":"query/","text":"Query Queries are similar to jq 's filter mechanism Both quering modes listed below are are mutually exclusive. By default, the 'simple' method is used by default. The parser will automatically switch to 'advanced' mode if your query contains a [ A word of caution, remember there are three different quoting behaviors within Bash itself ( \"string\" , 'string' , $'string' ), some of which have escape sequences as well. I recommend surrounding queries with '' where possible Simple query This mode is meant to be fast, and simply splits the dot deliminated string into an array, skipping any empty elements query='.my_key.sub_key' # => ('my_key' 'sub_key') Since this is mean to be fast, no checks are made. This means any particular query element could contain any character except . and [ query='..m!y_k@e y.....su\\\\]b_\"ke\\y' # => ('m!y_k@e y' 'su\\\\]b_\"ke\\y') Obviously, writing the query in that way is highly undesirable, so like jq , please ensure keys are made up of alphanumeric characters and underscores (without starting with a digit) Advanced query In this mode, all query elements are contained within square brackets. You must use this syntax if you wish to obtain a particular index from an array The rules follow Use quotes for strings (accessing keys in associative arrays) Everything inside quotes is literal, excluding three characters that have escape sequences: \\\\ , \\\" , and \\] The string cannot begin with $'\\x1C' , as that is how bash-object differentiates between a string and a number Do not use quotes for numbers (accessing indexes in indexed arrays) query='.[\"my.key\"].[\"s\\\\ub\\\"_key\\]\"]' # => ('my.key' 's\\ub\"_key]') query='.[\"my_key\"].[3]' # => ('my_key' $'\\x1C3') Invalid queries The following query is invalid because it mixes the 'simple' and 'advanced' query types within the same query query='.my_key.[3]'","title":"Query"},{"location":"query/#query","text":"Queries are similar to jq 's filter mechanism Both quering modes listed below are are mutually exclusive. By default, the 'simple' method is used by default. The parser will automatically switch to 'advanced' mode if your query contains a [ A word of caution, remember there are three different quoting behaviors within Bash itself ( \"string\" , 'string' , $'string' ), some of which have escape sequences as well. I recommend surrounding queries with '' where possible","title":"Query"},{"location":"query/#simple-query","text":"This mode is meant to be fast, and simply splits the dot deliminated string into an array, skipping any empty elements query='.my_key.sub_key' # => ('my_key' 'sub_key') Since this is mean to be fast, no checks are made. This means any particular query element could contain any character except . and [ query='..m!y_k@e y.....su\\\\]b_\"ke\\y' # => ('m!y_k@e y' 'su\\\\]b_\"ke\\y') Obviously, writing the query in that way is highly undesirable, so like jq , please ensure keys are made up of alphanumeric characters and underscores (without starting with a digit)","title":"Simple query"},{"location":"query/#advanced-query","text":"In this mode, all query elements are contained within square brackets. You must use this syntax if you wish to obtain a particular index from an array The rules follow Use quotes for strings (accessing keys in associative arrays) Everything inside quotes is literal, excluding three characters that have escape sequences: \\\\ , \\\" , and \\] The string cannot begin with $'\\x1C' , as that is how bash-object differentiates between a string and a number Do not use quotes for numbers (accessing indexes in indexed arrays) query='.[\"my.key\"].[\"s\\\\ub\\\"_key\\]\"]' # => ('my.key' 's\\ub\"_key]') query='.[\"my_key\"].[3]' # => ('my_key' $'\\x1C3')","title":"Advanced query"},{"location":"query/#invalid-queries","text":"The following query is invalid because it mixes the 'simple' and 'advanced' query types within the same query query='.my_key.[3]'","title":"Invalid queries"},{"location":"reference/","text":"Reference Environment Variables TRACE_BASH_OBJECT_TRAVERSE Setting this prints diagnostic info for debugging how bash-object traverses the object hierarchy TRACE_BASH_OBJECT_PARSE Setting this prints diagnostic info for debugging the querytree parser","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#environment-variables","text":"","title":"Environment Variables"},{"location":"reference/#trace_bash_object_traverse","text":"Setting this prints diagnostic info for debugging how bash-object traverses the object hierarchy","title":"TRACE_BASH_OBJECT_TRAVERSE"},{"location":"reference/#trace_bash_object_parse","text":"Setting this prints diagnostic info for debugging the querytree parser","title":"TRACE_BASH_OBJECT_PARSE"},{"location":"internals/errors/","text":"Errors Because Bash often does the wrong thing silently, it's important to fail early. This page documents the types of errors bash-object catches when using its functionality Export the VERIFY_BASH_OBJECT variable if you want to perform extra validation checks on input. On newer Bash versions this will incur little overhead; on older ones this will spawn subshells (which is why it's not by default enabled) Error Categories Generally, there are three categories of errors 1. Arguments Prefixed with ERROR_ARGUMENTS_ , these error codes will show when there is something wrong with the passed flags or arguments. We will check to ensure the correct number of arguments have been passed (and are non empty). Additionally, we will ensure that the passed arguments have continuity with whatever you reference. For example, if you want to --ref set-object , we will ensure that the variable you specify is a defined variable, and actually is an object (associative array). Another example, if you wish to set or get a variable, it will check to ensure the variable at the place you specify with the querystring is the same type as you specified as an argument (e.g. set-array ) 2. Querytree Prefixed with ERROR_QUERYTREE_ , these error codes will show when there is something wrong with parsing the querytree, namely syntax errors. A message associated with the error code will specify why the querytree couldn't be fixed, along with possible solutions 3. Virtual objects Prefixed with ERROR_VOBJ_ , these error codes will show when the virtual object does not match up with its reference. For example, if a virtual object looks like $'\\x1C\\x1Dtype=array;&SUB_OBJECT' , an error will show because it is referencing an object with the variable name SUB_OBJECT , but type=array is specified","title":"Errors"},{"location":"internals/errors/#errors","text":"Because Bash often does the wrong thing silently, it's important to fail early. This page documents the types of errors bash-object catches when using its functionality Export the VERIFY_BASH_OBJECT variable if you want to perform extra validation checks on input. On newer Bash versions this will incur little overhead; on older ones this will spawn subshells (which is why it's not by default enabled)","title":"Errors"},{"location":"internals/errors/#error-categories","text":"Generally, there are three categories of errors","title":"Error Categories"},{"location":"internals/errors/#1-arguments","text":"Prefixed with ERROR_ARGUMENTS_ , these error codes will show when there is something wrong with the passed flags or arguments. We will check to ensure the correct number of arguments have been passed (and are non empty). Additionally, we will ensure that the passed arguments have continuity with whatever you reference. For example, if you want to --ref set-object , we will ensure that the variable you specify is a defined variable, and actually is an object (associative array). Another example, if you wish to set or get a variable, it will check to ensure the variable at the place you specify with the querystring is the same type as you specified as an argument (e.g. set-array )","title":"1. Arguments"},{"location":"internals/errors/#2-querytree","text":"Prefixed with ERROR_QUERYTREE_ , these error codes will show when there is something wrong with parsing the querytree, namely syntax errors. A message associated with the error code will specify why the querytree couldn't be fixed, along with possible solutions","title":"2. Querytree"},{"location":"internals/errors/#3-virtual-objects","text":"Prefixed with ERROR_VOBJ_ , these error codes will show when the virtual object does not match up with its reference. For example, if a virtual object looks like $'\\x1C\\x1Dtype=array;&SUB_OBJECT' , an error will show because it is referencing an object with the variable name SUB_OBJECT , but type=array is specified","title":"3. Virtual objects"},{"location":"internals/virtual-object/","text":"Virtual Object Virtual objects are implemented as a string that contains some metadata and a reference to a variable. For example, in $'\\x1C\\x1Dtype=array;&SUB_OBJECT' , the metadata is type=array , and the reference is to the (global) variable SUB_OBJECT . Virutal objects always start with $'\\x1C\\x1D , to identify them amongst regular strings The type=<type> may look redundant since the type can be checked without subshell creation with ${var@a} or ${var@A} . However, this only works on newer Bash versions. Additionally, it is faster to check the types when setting the object and then saving that data as a string, rather than re-checking the type on every access. Lastly, bash-object may be extended in the future to support custom objects, so a field for it in the meatdata is useful","title":"Virtual Object"},{"location":"internals/virtual-object/#virtual-object","text":"Virtual objects are implemented as a string that contains some metadata and a reference to a variable. For example, in $'\\x1C\\x1Dtype=array;&SUB_OBJECT' , the metadata is type=array , and the reference is to the (global) variable SUB_OBJECT . Virutal objects always start with $'\\x1C\\x1D , to identify them amongst regular strings The type=<type> may look redundant since the type can be checked without subshell creation with ${var@a} or ${var@A} . However, this only works on newer Bash versions. Additionally, it is faster to check the types when setting the object and then saving that data as a string, rather than re-checking the type on every access. Lastly, bash-object may be extended in the future to support custom objects, so a field for it in the meatdata is useful","title":"Virtual Object"}]}